# Effective Java（五）

### 异常

### 六十九、只针对异常的情况使用异常

不要把异常用来做控制流。

### 七十、可恢复的情况使用受检异常，错误情况使用运行时异常

如果期望调用者能够适当的恢复，使用受检异常。通过抛出受检异常，强迫调用者处理异常，或者继续向外层调用者抛异常。

运行时异常和错误用来处理不要要也不应该被捕获的异常情况。

### 七十五、在细节消息中包含失败-捕获信息

为了捕获失败，异常的细节信息应该包含“对该异常有贡献”的所有参数和域的值。

### 七十六、努力使失败保持原子性

一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被称为具有失败原子性（ failure atomic ）。

有以下做法：

1. 提前校验，在对象状态被修改之前抛出适当异常；
2. 调整代码处理过程，使可能失败的计算部分都在对象状态被修改之前；
3. 临时拷贝；
4. 写恢复代码

如果对象状态已经被修改，发生异常之后，对象应该处于不可用状态。例如，多线程下，无同步机制下发生ConcurrentModificationException异常，此时对象状态不一致，不应努力去保持失败原子’性。

### 七十七、不要忽略异常

不管异常代表了可预见的异常条件，还是编程错误，用空的catch 块忽略它，都将导致程序在遇到错误的情况下悄然地执行下去。然后，有可能在将来的某个点上，当程序不能再容忍与错误源明显相关的问题时，它就会失败。正确地处理异常能够彻底避免失败。只要将异常传播给外界，至少会导致程序迅速失败，从而保留了有助于调试该失败条件的信息。